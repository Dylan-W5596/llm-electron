# 錯誤日誌：會話刪除後再次出現 (ID 重用與訊息殘留) [FINAL FIX]

## 1. 問題描述 (Issue)
使用者反映：點擊刪除對話後，對話似乎並未真正消失，或是內容依然殘留。

執行日誌顯示：
`DELETE /sessions/4` 成功回傳 200，但隨後 `POST /sessions` 生成的新對話 ID 又是 4。

---

## 2. 根本原因分析 (Root Cause)
1.  **SQLite 級聯刪除失效**: SQLite 預設不啟用外鍵約束。因此雖然 `sessions` 表刪除了 ID 4，但 `messages` 表中屬於 ID 4 的訊息依然殘留在硬碟中（孤兒訊息）。
2.  **ID 重複使用 (Reuse)**: 在未設定 `AUTOINCREMENT` 的情況下，SQLite 會傾向於重複使用已刪除的最大 ID。
3.  **邏輯連鎖**:
    - 刪除會話 4 (帶內容)。
    - 系統立即自動建立一個「新對話」，SQLite 分配了 ID 4 給它。
    - 前端嘗試讀取 ID 4 的訊息。
    - **結果**: 讀取到了原本殘留在資料庫中、屬於「舊會話 4」的訊息。

---

## 3. 解決方案 (Solution)
1.  **開啟 PRAGMA**: 在 `database.py` 透過事件監聽器，確保每個 SQLite 連線都執行 `PRAGMA foreign_keys = ON`。
2.  **防止 ID 重用**: 為 `ChatSession` 模型加上 `sqlite_autoincrement=True`。
3.  **重置架構**: 刪除舊的 `.db` 檔案以完整套用全新的資料表定義。
4.  **改進前端行為**: 當刪除目前的會話時，優先跳轉至「其他現有會話」，只有在全空時才建立「新對話」，避免視覺上的 ID 閃爍。

---

## 4. 解決歷程 (Solution History)
1. **分析**: 透過自製的 `check_db.py` 發現即使前端發送了 DELETE，ID 4 仍然很快就重新出現在 `sessions` 表中且伴隨著舊訊息。
2. **定位**: 確認為 SQLite 的預設機制與開發中的自動建立邏輯衝突。
3. **執行**: 重構 `database.py` 以強化資料完整性。
4. **驗證**: 清空資料庫後重新測試，刪除操作已能徹底清空資料且不再發生 ID 衝突。

---

## 5. 預防措施 (Prevention)
*   **預設開啟外鍵**: 任何使用 SQLite 的專案應在連線層就強制開啟外鍵。
*   **慎用 Auto-create**: 自動建立初始資料的邏輯應更謹慎，避免在刪除動作後立即觸發。

---
**紀錄日期**: 2026-01-22  
**處理人員**: Antigravity (AI Assistant)
